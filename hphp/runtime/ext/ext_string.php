<?hh
// generated by idl-to-hni.php

/* Returns a string with backslashes before characters that are listed in
 * charlist parameter.
 * @param string $str - The string to be escaped.
 * @param string $charlist - A list of characters to be escaped. If charlist
 * contains characters \n, \r etc., they are converted in C-like style, while
 * other non-alphanumeric characters with ASCII codes lower than 32 and higher
 * than 126 converted to octal representation.  When you define a sequence of
 * characters in the charlist argument make sure that you know what characters
 * come between the characters that you set as the start and end of the range.
 *  Also, if the first character in a range has a higher ASCII value than the
 * second character in the range, no range will be constructed. Only the
 * start, end and period characters will be escaped. Use the ord() function to
 * find the ASCII value for a character.    Be careful if you choose to escape
 * characters 0, a, b, f, n, r, t and v. They will be converted to \0, \a, \b,
 * \f, \n, \r, \t and \v. In PHP \0 (NULL), \r (carriage return), \n
 * (newline), \f (form feed), \v (vertical tab) and \t (tab) are predefined
 * escape sequences, while in C all of these are predefined escape sequences.
 * @return string - Returns the escaped string.
 */
<<__Native>>
function addcslashes(string $str,
                     string $charlist): string;

/* Returns a string with backslashes stripped off. Recognizes C-like \n, \r
 * ..., octal and hexadecimal representation.
 * @param string $str - The string to be unescaped.
 * @return string - Returns the unescaped string.
 */
<<__Native>>
function stripcslashes(string $str): string;

/* Returns a string with backslashes before characters that need to be quoted
 * in database queries etc. These characters are single quote ('), double
 * quote ("), backslash (\) and NUL (the NULL byte).  An example use of
 * addslashes() is when you're entering data into a database. For example, to
 * insert the name O'reilly into a database, you will need to escape it. It's
 * highly recommended to use DBMS specific escape function (e.g.
 * mysqli_real_escape_string() for MySQL or pg_escape_string() for
 * PostgreSQL), but if the DBMS you're using does't have an escape function
 * and the DBMS uses \ to escape special chars, you can use this function.
 * This would only be to get the data into the database, the extra \ will not
 * be inserted. Having the PHP directive magic_quotes_sybase set to on will
 * mean ' is instead escaped with another '.  The PHP directive
 * magic_quotes_gpc is on by default, and it essentially runs addslashes() on
 * all GET, POST, and COOKIE data. Do not use addslashes() on strings that
 * have already been escaped with magic_quotes_gpc as you'll then do double
 * escaping. The function get_magic_quotes_gpc() may come in handy for
 * checking this.
 * @param string $str - The string to be escaped.
 * @return string - Returns the escaped string.
 */
<<__Native>>
function addslashes(string $str): string;

/* Un-quotes a quoted string.  If magic_quotes_sybase is on, no backslashes
 * are stripped off but two apostrophes are replaced by one instead.  An
 * example use of stripslashes() is when the PHP directive magic_quotes_gpc is
 * on (it's on by default), and you aren't inserting this data into a place
 * (such as a database) that requires escaping. For example, if you're simply
 * outputting data straight from an HTML form.
 * @param string $str - The input string.
 * @return string - Returns a string with backslashes stripped off. (\'
 * becomes ' and so on.) Double backslashes (\\) are made into a single
 * backslash (\).
 */
<<__Native>>
function stripslashes(string $str): string;

/* Returns an ASCII string containing the hexadecimal representation of str.
 * The conversion is done byte-wise with the high-nibble first.
 * @param string $str - A character.
 * @return string - Returns the hexadecimal representation of the given
 * string.
 */
<<__Native>>
function bin2hex(string $str): string;

/* Returns an ASCII string containing the binary representation of hexidecimal
 * str.
 * @param string $str - A character.
 * @return mixed - Returns the binary representation of the given hexidecimal
 * string or FALSE on failure.
 */
<<__Native>>
function hex2bin(string $str): mixed;

/* Returns string with '<br />' or '<br>' inserted before all newlines.
 * @param string $str - The input string.
 * @param bool $is_xhtml - Whether to use XHTML compatible line breaks or not.
 * @return string - Returns the altered string.
 */
function nl2br(mixed $str,
               mixed $is_xhtml = true): string {
  if ($is_xhtml) {
    return str_replace("\n", "<br />\n", $str);
  } else {
    return str_replace("\n", "<br>\n", $str);
  }
}

/* Returns a version of str with a backslash character (\) before every
 * character that is among these: . \ + * ? [ ^ ] ( $ )
 * @param string $str - The input string.
 * @return string - Returns the string with meta characters quoted.
 */
<<__Native>>
function quotemeta(string $str): string;

/* @param string $str - The input string.
 * @return string - Returns the shuffled string.
 */
<<__Native>>
function str_shuffle(string $str): string;

/* Returns string, reversed.
 * @param string $str - The string to be reversed.
 * @return string - Returns the reversed string.
 */
<<__Native>>
function strrev(string $str): string;

/* Returns string with all alphabetic characters converted to lowercase.  Note
 * that 'alphabetic' is determined by the current locale. This means that in
 * i.e. the default "C" locale, characters such as umlaut-A () will not be
 * converted.
 * @param string $str - The input string.
 * @return string - Returns the lowercased string.
 */
<<__Native>>
function strtolower(string $str): string;

/* Returns string with all alphabetic characters converted to uppercase.  Note
 * that 'alphabetic' is determined by the current locale. For instance, in the
 * default "C" locale characters such as umlaut-a () will not be converted.
 * @param string $str - The input string.
 * @return string - Returns the uppercased string.
 */
<<__Native>>
function strtoupper(string $str): string;

/* Returns a string with the first character of str capitalized, if that
 * character is alphabetic.  Note that 'alphabetic' is determined by the
 * current locale. For instance, in the default "C" locale characters such as
 * umlaut-a () will not be converted.
 * @param string $str - The input string.
 * @return string - Returns the resulting string.
 */
<<__Native>>
function ucfirst(string $str): string;

/* Returns a string with the first character of str , lowercased if that
 * character is alphabetic.  Note that 'alphabetic' is determined by the
 * current locale. For instance, in the default "C" locale characters such as
 * umlaut-a (Ã¤) will not be converted.
 * @param string $str - The input string.
 * @return string - Returns the resulting string.
 */
<<__Native>>
function lcfirst(string $str): string;

/* Returns a string with the first character of each word in str capitalized,
 * if that character is alphabetic.  The definition of a word is any string of
 * characters that is immediately after a whitespace (These are: space,
 * form-feed, newline, carriage return, horizontal tab, and vertical tab).
 * @param string $str - The input string.
 * @return string - Returns the modified string.
 */
<<__Native>>
function ucwords(string $str): string;

/* This function tries to return a string with all NUL bytes, HTML and PHP
 * tags stripped from a given str. It uses the same tag stripping state
 * machine as the fgetss() function.
 * @param string $str - The input string.
 * @param string $allowable_tags - You can use the optional second parameter
 * to specify tags which should not be stripped.  HTML comments and PHP tags
 * are also stripped. This is hardcoded and can not be changed with
 * allowable_tags.
 * @return string - Returns the stripped string.
 */
<<__Native>>
function strip_tags(string $str,
                    string $allowable_tags = ""): string;

/* This function returns a string with whitespace stripped from the beginning
 * and end of str. Without the second parameter, trim() will strip these
 * characters: " " (ASCII 32 (0x20)), an ordinary space. "\t" (ASCII 9
 * (0x09)), a tab. "\n" (ASCII 10 (0x0A)), a new line (line feed). "\r" (ASCII
 * 13 (0x0D)), a carriage return. "\0" (ASCII 0 (0x00)), the NUL-byte. "\x0B"
 * (ASCII 11 (0x0B)), a vertical tab.
 * @param string $str - The string that will be trimmed.
 * @param string $charlist - Optionally, the stripped characters can also be
 * specified using the charlist parameter. Simply list all characters that you
 * want to be stripped. With .. you can specify a range of characters.
 * @return string - The trimmed string.
 */
<<__Native>>
function trim(string $str,
              string $charlist = HPHP_TRIM_CHARLIST): string;

/* Strip whitespace (or other characters) from the beginning of a string.
 * @param string $str - The input string.
 * @param string $charlist - You can also specify the characters you want to
 * strip, by means of the charlist parameter. Simply list all characters that
 * you want to be stripped. With .. you can specify a range of characters.
 * @return string - This function returns a string with whitespace stripped
 * from the beginning of str. Without the second parameter, ltrim() will strip
 * these characters: " " (ASCII 32 (0x20)), an ordinary space. "\t" (ASCII 9
 * (0x09)), a tab. "\n" (ASCII 10 (0x0A)), a new line (line feed). "\r" (ASCII
 * 13 (0x0D)), a carriage return. "\0" (ASCII 0 (0x00)), the NUL-byte. "\x0B"
 * (ASCII 11 (0x0B)), a vertical tab.
 */
<<__Native>>
function ltrim(string $str,
               string $charlist = HPHP_TRIM_CHARLIST): string;

/* This function returns a string with whitespace stripped from the end of
 * str.  Without the second parameter, rtrim() will strip these characters: "
 * " (ASCII 32 (0x20)), an ordinary space. "\t" (ASCII 9 (0x09)), a tab. "\n"
 * (ASCII 10 (0x0A)), a new line (line feed). "\r" (ASCII 13 (0x0D)), a
 * carriage return. "\0" (ASCII 0 (0x00)), the NUL-byte. "\x0B" (ASCII 11
 * (0x0B)), a vertical tab.
 * @param string $str - The input string.
 * @param string $charlist - You can also specify the characters you want to
 * strip, by means of the charlist parameter. Simply list all characters that
 * you want to be stripped. With .. you can specify a range of characters.
 * @return string - Returns the modified string.
 */
<<__Native>>
function rtrim(string $str,
               string $charlist = HPHP_TRIM_CHARLIST): string;

/* @param string $str
 * @param string $charlist
 * @return string
 */
<<__Native>>
function chop(string $str,
              string $charlist = HPHP_TRIM_CHARLIST): string;

/* Returns an array of strings, each of which is a substring of string formed
 * by splitting it on boundaries formed by the string delimiter. Although
 * implode() can, for historical reasons, accept its parameters in either
 * order, explode() cannot. You must ensure that the delimiter argument comes
 * before the string argument.
 * @param string $delimiter - The boundary string.
 * @param string $str - The input string.
 * @param int $limit - If limit is set and positive, the returned array will
 * contain a maximum of limit elements with the last element containing the
 * rest of string.  If the limit parameter is negative, all components except
 * the last -limit are returned.  If the limit parameter is zero, then this is
 * treated as 1.
 * @return mixed - Returns an array of strings created by splitting the string
 * parameter on boundaries formed by the delimiter.  If delimiter is an empty
 * string (""), explode() will return FALSE. If delimiter contains a value
 * that is not contained in string and a negative limit is used, then an empty
 * arraywill be returned, otherwise an array containing string will be
 * returned.
 */
<<__Native>>
function explode(string $delimiter,
                 string $str,
                 int $limit = 0x7FFFFFFF): mixed;

/* Join container elements with a glue string.  implode() can, for historical
 * reasons, accept its parameters in either order. For consistency with
 * explode(), however, it may be less confusing to use the documented order of
 * arguments.
 * @param mixed $arg1 - Defaults to an empty string. This is not the preferred
 * usage of implode() as glue would be the second parameter and thus, the bad
 * prototype would be used.
 * @param mixed $arg2 - The array of strings to implode.
 * @return string - Returns a string containing a string representation of all
 * the array elements in the same order, with the glue string between each
 * element.
 */
<<__Native>>
function implode(mixed $arg1,
                 mixed $arg2 = null): string;

/* An alias for implode().
 * @param mixed $glue
 * @param mixed $pieces
 * @return string
 */
<<__Native>>
function join(mixed $glue,
              mixed $pieces = null): string;

/* Converts a string to an array.
 * @param string $str - The input string.
 * @param int $split_length - Maximum length of the chunk.
 * @return mixed - If the optional split_length parameter is specified, the
 * returned array will be broken down into chunks with each being split_length
 * in length, otherwise each chunk will be one character in length.  FALSE is
 * returned if split_length is less than 1. If the split_length length exceeds
 * the length of string, the entire string is returned as the first (and only)
 * array element.
 */
<<__ParamCoerceModeNull, __Native>>
function str_split(string $str,
                   int $split_length = 1): mixed;

/* Can be used to split a string into smaller chunks which is useful for e.g.
 * converting base64_encode() output to match RFC 2045 semantics. It inserts
 * end every chunklen characters.
 * @param string $body - The string to be chunked.
 * @param int $chunklen - The chunk length.
 * @param string $end - The line ending sequence.
 * @return mixed - Returns the chunked string.
 */
<<__Native>>
function chunk_split(string $body,
                     int $chunklen = 76,
                     string $end = "\r\n"): mixed;

/* strtok() splits a string (str) into smaller strings (tokens), with each
 * token being delimited by any character from token. That is, if you have a
 * string like "This is an example string" you could tokenize this string into
 * its individual words by using the space character as the token.  Note that
 * only the first call to strtok uses the string argument. Every subsequent
 * call to strtok only needs the token to use, as it keeps track of where it
 * is in the current string. To start over, or to tokenize a new string you
 * simply call strtok with the string argument again to initialize it. Note
 * that you may put multiple tokens in the token parameter. The string will be
 * tokenized when any one of the characters in the argument are found.
 * @param string $str - The string being split up into smaller strings
 * (tokens).
 * @param mixed $token - The delimiter used when splitting up str.
 * @return mixed - A string token.
 */
<<__Native>>
function strtok(string $str,
                mixed $token = null): mixed;

/* This function returns a string or an array with all occurrences of search
 * in subject replaced with the given replace value.  If you don't need fancy
 * replacing rules (like regular expressions), you should always use this
 * function instead of ereg_replace() or preg_replace(). If search and replace
 * are arrays, then str_replace() takes a value from each array and uses them
 * to do search and replace on subject. If replace has fewer values than
 * search, then an empty string is used for the rest of replacement values. If
 * search is an array and replace is a string, then this replacement string is
 * used for every value of search. The converse would not make sense, though. 
 * If search or replace are arrays, their elements are processed first to
 * last.
 * @param mixed $search - The value being searched for, otherwise known as the
 * needle. An array may be used to designate multiple needles.
 * @param mixed $replace - The replacement value that replaces found search
 * values. An array may be used to designate multiple replacements.
 * @param mixed $subject - The string or array being searched and replaced on,
 * otherwise known as the haystack.  If subject is an array, then the search
 * and replace is performed with every entry of subject, and the return value
 * is an array as well.
 * @param mixed $count - If passed, this will hold the number of matched and
 * replaced needles.
 * @return mixed - This function returns a string or an array with the
 * replaced values.
 */
<<__Native>>
function str_replace(mixed $search,
                     mixed $replace,
                     mixed $subject,
                     mixed &$count = null): mixed;

/* This function returns a string or an array with all occurrences of search
 * in subject (ignoring case) replaced with the given replace value. If you
 * don't need fancy replacing rules, you should generally use this function
 * instead of preg_replace() with the i modifier. If search and replace are
 * arrays, then str_ireplace() takes a value from each array and uses them to
 * do search and replace on subject. If replace has fewer values than search,
 * then an empty string is used for the rest of replacement values. If search
 * is an array and replace is a string, then this replacement string is used
 * for every value of search.
 * @param mixed $search - Every replacement with search array is performed on
 * the result of previous replacement.
 * @param mixed $replace
 * @param mixed $subject - If subject is an array, then the search and replace
 * is performed with every entry of subject, and the return value is an array
 * as well.
 * @param mixed $count - The number of matched and replaced needles will be
 * returned in count which is passed by reference.
 * @return mixed - Returns a string or an array of replacements.
 */
<<__Native>>
function str_ireplace(mixed $search,
                      mixed $replace,
                      mixed $subject,
                      mixed &$count = null): mixed;

/* substr_replace() replaces a copy of string delimited by the start and
 * (optionally) length parameters with the string given in replacement.
 * @param mixed $str - The input string.
 * @param mixed $replacement - The replacement string.
 * @param mixed $start - If start is positive, the replacing will begin at the
 * start'th offset into string.  If start is negative, the replacing will
 * begin at the start'th character from the end of string.
 * @param mixed $length - If given and is positive, it represents the length
 * of the portion of string which is to be replaced. If it is negative, it
 * represents the number of characters from the end of string at which to stop
 * replacing. If it is not given, then it will default to strlen( string );
 * i.e. end the replacing at the end of string. Of course, if length is zero
 * then this function will have the effect of inserting replacement into
 * string at the given start offset.
 * @return mixed - The result string is returned. If string is an array then
 * array is returned.
 */
<<__Native>>
function substr_replace(mixed $str,
                        mixed $replacement,
                        mixed $start,
                        mixed $length = 0x7FFFFFFF): mixed;

/* Returns the portion of string specified by the start and length parameters.
 * @param string $str - The input string.
 * @param int $start - If start is non-negative, the returned string will
 * start at the start'th position in string, counting from zero. For instance,
 * in the string 'abcdef', the character at position 0 is 'a', the character
 * at position 2 is 'c', and so forth.  If start is negative, the returned
 * string will start at the start'th character from the end of string.  If
 * string is less than or equal to start characters long, FALSE will be
 * returned.  Example #1 Using a negative start
 * @param int $length - If length is given and is positive, the string
 * returned will contain at most length characters beginning from start
 * (depending on the length of string).  If length is given and is negative,
 * then that many characters will be omitted from the end of string (after the
 * start position has been calculated when a start is negative). If start
 * denotes a position beyond this truncation, an empty string will be
 * returned.  If length is given and is 0, FALSE or NULL an empty string will
 * be returned.  If length is omitted, the substring starting from start until
 * the end of the string will be returned. Example #2 Using a negative length
 * @return mixed - Returns the extracted part of string or FALSE on failure.
 */
<<__ParamCoerceModeNull, __Native>>
function substr(string $str,
                int $start,
                int $length = 0x7FFFFFFF): mixed;

/* This functions returns the input string padded on the left, the right, or
 * both sides to the specified padding length. If the optional argument
 * pad_string is not supplied, the input is padded with spaces, otherwise it
 * is padded with characters from pad_string up to the limit.
 * @param string $input - The input string.
 * @param int $pad_length - If the value of pad_length is negative, less than,
 * or equal to the length of the input string, no padding takes place.
 * @param string $pad_string - The pad_string may be truncated if the required
 * number of padding characters can't be evenly divided by the pad_string's
 * length.
 * @param int $pad_type - Optional argument pad_type can be STR_PAD_RIGHT,
 * STR_PAD_LEFT, or STR_PAD_BOTH. If pad_type is not specified it is assumed
 * to be STR_PAD_RIGHT.
 * @return string - Returns the padded string.
 */
<<__Native>>
function str_pad(string $input,
                 int $pad_length,
                 string $pad_string = " ",
                 int $pad_type = STR_PAD_RIGHT): string;

/* Returns input repeated multiplier times.
 * @param string $input - The string to be repeated.
 * @param int $multiplier - Number of time the input string should be
 * repeated.  multiplier has to be greater than or equal to 0. If the
 * multiplier is set to 0, the function will return an empty string.
 * @return string - Returns the repeated string.
 */
<<__Native>>
function str_repeat(string $input,
                    int $multiplier): string;


/**
* Case-insensitive
*
* @param string $haystack - The string to search in
* @param mixed $needle - If needle is not a string, it is converted to
* an integer and applied as the ordinal value of a character.
* @param bool $before_needle - If TRUE, stristr() returns the part of
* the haystack before the first occurrence of the needle (excluding
* needle).
*
* @return string - Returns the matched substring. If needle is not
* found, returns FALSE.
*/
<<__IsFoldable>>
function stristr(mixed $haystack, mixed $needle,
                 mixed $before_needle = false): mixed {
  $ret = stripos($haystack, $needle);
  if ($ret === false) {
    return false;
  }
  if ($before_needle) {
    return substr($haystack, 0, $ret);
  } else {
    return substr($haystack, $ret);
  }
}
